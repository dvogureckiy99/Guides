# Рекомендации по организации архитектуры ПО для микроконтроллеров

## Модульность

Организация кода ПО (программное обеспечение) имеет очень важную роль, так как это улучшает его читаемость и может исключить огромное количество ошибок. Часто программы для микроконтроллеров представляют собой следующую схему: драйверы оборудования (железа) + алгоритмы. По этой схеме в коде программы вся логика разбивается на ответственные части, так, например, в первой лабораторной у вас присутствуют модули энкодера и семисегментного индикатора, а также основная логика программы, которая использует драйверы модулей.

Под модулями часто понимают составную часть программы (ее логики), поэтому необходимо научиться добавлять .с файлы в проект, для того, чтобы размещать в отдельных модулях код. Для CodevisionAVR это делается следующим образом:
- открыть конфигурацию проекта (Project -> Configuration)

<p align="center">
<img src="c_uc_recommendations_pics/screen0.png">
</p>

<p align="center">
<img src="c_uc_recommendations_pics/screen1.png">
</p>

- добавить новый .с файл и назвать его в соответствии с названием драйвера или алгоритма (части алгоритма).

Для приведенного примера, рекомендуется весь код, который относится к семисегментному индикатору, вынести в модуль драйвера этого индикатора (.с файл, например назван `semisegment.c`). Так, например, в модуль попадает список кодов цифр, по которым драйвер будет выводить их на сам индикатор:
```c++
const unsigned char segments[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D,0x7D, 0x07, 0x7F, 0x6F};
```

Также часто любой модуль имеет функции `init` и `deinit`, которые выполняют задачи инициализации и освобождения ресурсов. Если первая функция реализуется почти постоянно, то вторая очень часто опускается. Для нашего случая функция инициализации в модуле индикатора может выглядеть следующим образом:
```c++
void semiseg_init( void )
{
    /* Setup latch pins direction */
    DDRA |= 0b00111110;
    
    /* Setup code pins direction */
    DDRC = 0xFF;
}
```

> В названии функции всегда есть две части: название модуля и сама функция. Сделано это с целью разграничения, так как функция инициализации (а может и другая функция) может присутствовать сразу в нескольких модулях.

При правильном использовании модульности для каждого модуля (например, semisegment.c) создаётся файл заголовка (обычно назван также, для нашего примера semisegment.h), в который размещаются прототипы функций, открытые для использования другими модулями (или алгоритмами).

> Ведь внутри модуля могут быть и закрытые функции, которые по задумке нельзя использовать снаружи модуля.

Создаётся заголовочный файл по аналогии с .с файлом. Для примера, в файле заголовка могут быть перечислены функции индикатора:
```c++
void semiseg_init( void );
void semiseg_print ( int number );
```

Для использования функций модуля индикатора в другом модуле производится "подключение" модуля:
```c++
#include <semisegment.h>
```

> Это не подключение библиотеки! Это сообщение модулю, какие функции другого модуля можно использовать; код модуля сразу компилируется с кодом основной программы.

Таким образом, принцип модульности позволяет разбить логику программы на малые кусочки, что позволит в дальнейшем упростить переносимость программы на другие платформы и переиспользование кода в других проектах. Более того, модульность поднимает читаемость кода на другой уровень.

## Комментарии

Практика комментариев распространена очень широко и не надо объяснять их важность. Часто комментарии могут относиться к кусочку кода:
```с++
/* This part of code fills array with ordered indexes */
```

а также к функциям модуля:
```с++
/* This function calculates sum of two numbers, input - numbers to sum, output - result */
```

Примеров того, как писать комментарии (стиль комментариев), в интернете очень много. В данной рекомендаций предлагаю обратить внимание на стиль, который стандартизован для системы Doxygen. В таком стиле в заголовке будет располагаться прототип функции получения угла поворота модуля драйвера энкодера:
```с++
/**
 * @brief    Get angle position of encoder
 * @return   Angle position 0-360 [degree]
 */
int encoder_get_angle_degree( void );
```

Для функции с параметрами будет присутствовать ещё один важный тэг `@param`, также тэгом @note можно отметить на которые особенности функции:
```с++
/**
 * @brief    Print 5-digit number on indicator
 * @param    number   Number to print on indicator
 * @note     In case if number contains more digits (123456), less significant will be written (23456)
 */
void semiseg_print( int number );
```

## Константы модулей, конфигурация

Часто модуль содержит ряд параметров, которые не меняются в ходе работы, их можно назвать константными. Для примера можно привести параметр перевода тиков энкодеры в угол поворота. Практика показывает, что самым оптимальным методом будет размещение таких константных параметров в начале модуля (.с файла) с помощью директивы `define` и дальнейшее использование по коду модуля:
```c++
#define ENCODER_TICK_2_ANGLE 9

...

int angle = ticks * ENCODER_TICK_2_ANGLE;
```

> Определение директивой константы приводит к двум важным фактам. Во-первых, константы внутри модуля не видны снаружи другого модуля. Во-вторых, во время компиляции вместо имён констант (например `ENCODER_TICK_2_ANGLE`) подставляются значения этих констант, то есть стоит __аккуратно пользоваться, если вы пишите не просто число, а выражение (например, 360/40)__.

